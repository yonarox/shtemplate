#!/bin/sh 
# vim: set filetype=sh ts=2 sw=2 sts=2 et si ai: 

# jCommons.lib
# =
#
# Andres Aquino <aquino(at)hp.com>
# Hewlett-Packard Company | EBS
# 

# set Environment
jSetEnvironment () 
{
  if [ -z "${APP_HOME}" ]
  then
    PrintOut "Please, set APP_HOME"
    exit 1
  fi

  # load default parameters
  if [ ! -f "${APP_HOME}/vendor/java.env" ]
  then 
    PrintOut "Please, set vendor/java.env"
    exit 1
  fi
  source ${APP_HOME}/vendor/java.env

  # load user app parameters
  if [ ! -f "${APP_HOME}/cfg/appl.env" ]
  then 
    PrintOut "Please, set cfg/appl.env"
    exit 1
  fi
  source ${APP_HOME}/cfg/appl.env

  JAVA_FLAGS="-Dappname=${APP_NAME}"

}

# Heap Size of Memory
# This setting controls the size of the Java heap.
# Properly tuning this parameter reduces the overhead of garbage collection, 
# improving server response time and throughput. 
jSetSizeofMemory ()
{
  # Initial Size and Maximum
  local INITIAL=${1}
  local MAXIMUM=${2}
  
  # undeclared, then default values 
  [ ! -n "${INITIAL}" ] && INITIAL=${JMINITIAL}
  [ ! -n "${MAXIMUM}" ] && MAXIMUM=${JMMAXIMUM}

  # ... and setting
  JAVA_FLAGS="${JAVA_FLAGS} -Xms${INITIAL} -Xmx${MAXIMUM}"

}

# Permanent Generation Size of Memory on Hold
jSetPermSizeofMemory ()
{
  # Initial Size and Maximum
  local INITIAL=${1}
  local MAXIMUM=${2}
  
  # undeclared, then default values 
  [ ! -n "${INITIAL}" ] && INITIAL=${JPINITIAL}
  [ ! -n "${MAXIMUM}" ] && MAXIMUM=${JPMAXIMUM}

  # ... and setting
  JAVA_FLAGS="${JAVA_FLAGS} -XX:PermSize=${INITIAL} -X:MaxPermSize=${MAXIMUM}"

}

# Heap Dump of Memory
jSetHeapDump ()
{
  # set where heapdump exists
  local HEAPLOG="${APP_HOME}/logs/${_UTIME}.hprof"
  
  # ... and setting
  JAVA_FLAGS="${JAVA_FLAGS} -XX:+HeapDumpOnCtrlBreak"
  JAVA_FLAGS="${JAVA_FLAGS} -XX:HeapDumpPath=${HEAPLOG}"

}

# Garbage Collector behaviour
jSetGarbageCollector ()
{
  # set where heapdump exists
  local GARBAGELOG="${APP_HOME}/logs/${_UTIME}.gc"
  
  # ... and setting
  JAVA_FLAGS="${JAVA_FLAGS} -XX:+DisableExplicitGC"
  JAVA_FLAGS="${JAVA_FLAGS} -XX:file=${GARBAGELOG}"

}

# Timezone
# Set the timezone for a single instance of a JVM process.
jSetTimeZone ()
{
  # local time zone 
  local TIMEZONE=${1}

  # undeclared, use default value
  [ ! -n "${TIMEZONE}" ] && TIMEZONE=${JTIMEZONE}

  # ... and setting
  JAVA_FLAGS="${JAVA_FLAGS} -Duser.timezone=${TIMEZONE}"

}

# Security Policy of a JVM execution
# The policy for a Java application environment (specifying which 
# permissions are available for code from various sources) is 
# represented by a Policy object.
jSetSecurityPolicy ()
{
  #
  local POLICY=${1}

  # build policy path in this manner, Path = $APP_HOME + $POLICY 
  POLICY="${APP_HOME}/${POLICY}"

  # validate or use default value
  [ ! -f ${POLICY} ] && POLICY="${APP_HOME}/${JSEPOLICY}"

  # ... and setting
  JAVA_FLAGS="${JAVA_FLAGS} -Djava.security.policy=${POLICY}"

}

# Build a CLASSPATH
jBuildClasspath ()
{
  # Java Classes
  JAVA_CLASSPATH=
  for classfile in "${APP_HOME}/lib/*.jar"
  do
    JAVA_CLASSPATH="${classfile}:${JAVA_CLASSPATH}"
  done
  
  # if receive an additional directory
  [ -d ${APP_HOME}/${1} ] && JAVA_CLASSPATH="${APP_HOME}/${1}:${JAVA_CLASSPATH}"

  export CLASSPATH="${JAVA_CLASSPATH}:."

}

#
jLoadRMIProcess ()
{
  # initial RMI parameters 
  local RMIBASE=${1}
  local RMIPORT=${2}

  # undefined, use defaults
  [ -n "${RMIBASE}" ] && RMIBASE=${JP_RMIBASE}
  [ -n "${RMIPORT}" ] && RMIPORT=${JP_RMIPORT}

  # define flag
  RMIBASE="${APP_HOME}/lib/${RMIBASE}"
  [ -f ${APP_HOME}/${APP_NAME}-rmi.lck ] && PrintOut "Some RMI process exists" && return 1
  if [ ! -f ${RMIBASE} ]
  then
    LogMessage "Any RMI CodeBase file exists, verify ${RMIBASE}"
    return 1
  else
    echo "rmiregistry ${RMIPORT}" && return 0
    rmiregistry ${RMIPORT} 2>&1 &
    echo $! > ${APP_HOME}/${APP_NAME}-rmi.lck
    JAVA_RMI="file://${RMIBASE}"

  fi

}

#
jUnloadRMIProcess ()
{
  lockfile="${APP_HOME}/${APP_NAME}-rmi.lck"
  [ -f ${lockfile} ] && kill -9 $(cat ${lockfile}) && rm ${lockfile}
}

#
jLoadJARProcess ()
{
  # indicate to use RMI
  local CMD=${1}

  if [ "${CMD}" = "USE_RMI" ]
  then
    echo "java ${JAVA_FLAGS} ${JAVA_RMI} -jar ${RMIBASE}" && return 0
    java ${JAVA_FLAGS} ${JAVA_RMI} -jar ${RMIBASE} 2>&1 &
    echo $! > ${APP_HOME}/${APP_NAME}-jar.lck
  else
    echo "java ${JAVA_FLAGS} -jar ${RMIBASE}" && return 0
    java ${JAVA_FLAGS} -jar ${RMIBASE} 2>&1 &
    echo $! > ${APP_HOME}/${APP_NAME}-jar.lck

  fi

}

#
jUnloadJARProcess ()
{
  lockfile="${APP_HOME}/${APP_NAME}-jar.lck"
  [ -f ${lockfile} ] && kill -9 $(cat ${lockfile}) && rm ${lockfile}

}

#
jLoadCLASSProcess ()
{
  # indicate to use RMI
  local CMD=${1}

  echo "java ${JAVA_FLAGS} -cp ${CLASSPATH} ${JP_CLS} ${CMD}" && return 0
  java ${JAVA_FLAGS} -cp ${CLASSPATH} ${JP_CLS} ${CMD} 2>&1 &
  echo $! > ${APP_HOME}/${APP_NAME}-cls.lck

}

#
jUnloadCLASSProcess ()
{
  lockfile="${APP_HOME}/${APP_NAME}-cls.lck"
  [ -f ${lockfile} ] && kill -9 $(cat ${lockfile}) && rm ${lockfile}

}

#
